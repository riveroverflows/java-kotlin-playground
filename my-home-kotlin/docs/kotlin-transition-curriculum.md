# My Home Kotlin 전환 학습 커리큘럼

이 문서는 Java 콘솔 게임 `my-home-kotlin`을 Kotlin 사고방식으로 전환하기 위한 확정된 커리큘럼을 기록한다. 설계 단계는 이미 종료되었으며, 학습자·멘토·코드 리뷰어가 동일한 기준으로 진행 상태를 추적하기 위한 문서이다.

## 전체 진행 개요
- 단계 구성, 순서, 난이도, 관점은 확정된 상태이며 변경하지 않는다.
- 각 단계는 "설명이 가능한가"라는 사고 전환 관점을 완료 기준으로 삼는다.
- 멘토 세션과 코드 리뷰 세션은 이 문서의 체크 상태를 기준으로 진행하며, 실제 코드 전환은 문서에서 "실제 전환 시도 완료" 체크를 마친 후 시작한다.

---

## 1단계. 내러티브 루프를 상태 기계로 번역하기

### 1. 단계 정보
- **단계 번호**: 1
- **단계명**: 내러티브 루프를 상태 기계로 번역
- **핵심 목적**: 로딩 스토리, 플레이어 입력, 메인 메뉴, 지역 선택까지 이어지는 서사를 절차적 println 나열이 아닌 상태 전이로 설명할 수 있도록 정리한다.

### 2. 학습 목표
- 로딩/스토리/메뉴 흐름을 명시적인 상태 전이로 모델링한다.
- Kotlin의 표현식 기반 제어(`when`, 최상위 함수 분리 등)를 적용할 수 있는 지점을 말로 정리한다.
- 거대한 `switch`/`if` 블록을 역할별 상태 혹은 의도 기반 함수로 분리하는 사고를 체득한다.

### 3. 전환 대상
- 오프닝 로딩 시퀀스와 서사 출력
- 플레이어 이름 입력 및 검증 절차
- 메인 메뉴 표시와 입력 처리 루프
- 지역 선택(밭/동물농장/숲) 흐름과 반복 구조

### 4. Java ↔ Kotlin 사고 차이
- **Java식 사고**: `switch`와 반복적인 println으로 흐름을 절차적으로 나열하고, 입력을 즉시 처리하며 `return`/`continue`로 탈출한다.
- **Kotlin식 사고**: 상태(예: 휴식 여부, 메뉴 선택)를 표현식으로 모델링하고 의미 있는 함수 이름으로 전이를 기술하며, 출력 문자열은 템플릿과 블록으로 묶어 의도를 드러낸다.

### 5. 완료 판단 기준
- 각 메뉴 입력이 어떤 상태 전이를 의미하는지 Kotlin 표현식으로 설명할 수 있다.
- “플레이어 휴식 상태가 true일 때 메뉴가 어떻게 달라지는가?” 같은 질문에 상태 기계 관점으로 답할 수 있다.

### ▢ 진행 체크
- [ ] 아직 시작하지 않음
- [ ] 개념 이해 중
- [ ] 설명 가능
- [ ] 실제 전환 시도 완료

### ▢ 멘토 세션 확인 포인트
- 메인 루프의 상태 전이를 도식 없이 말로 설명할 수 있는가?
- 휴식 상태/피로도에 따라 메뉴가 어떻게 제한되는지 표현식 기반으로 정리했는가?
- 지역 선택 루프가 어떤 상태 전환을 트리거하는지 역할별로 구분했는가?

### ▢ 코드 리뷰 세션 확인 포인트
- Kotlin 코드에서 메뉴 분기가 의미 있는 함수/상태로 분리되어 있는가? (단순 숫자 `when` 유지 시 Java 사고 잔존)
- 출력/입력 로직이 상태 모델과 분리되어 있는가?
- 여전히 println 나열+`return` 제어만 존재한다면 Java식 절차적 사고가 유지된 것으로 간주한다.

---

## 2단계. 플레이어·인벤토리를 프로퍼티 중심 사고로 재구성하기

### 1. 단계 정보
- **단계 번호**: 2
- **단계명**: 플레이어/인벤토리 프로퍼티화
- **핵심 목적**: Player, Inventory, Quest, Title 등 핵심 데이터를 Kotlin 프로퍼티와 불변 값 객체의 관점에서 설명해, 상태 관리 책임을 명확히 한다.

### 2. 학습 목표
- Player와 Inventory의 상태를 프로퍼티/값 객체로 분해하여 설명한다.
- 불변 리스트·맵과 `data class` 관점을 통해 “데이터가 한 곳에서 진실을 유지”하도록 사고한다.
- 널 안정성과 기본값 처리 방식을 말로 정리한다.

### 3. 전환 대상
- Player 전체 상태(경험치, 피로도, 휴식 모드, 장비 보유 등)
- Inventory와 ItemEntry의 저장 구조, 퀘스트/타이틀 목록
- 상태를 수정하는 메서드(골드 변경, 퀘스트 추가 등)의 책임 구분

### 4. Java ↔ Kotlin 사고 차이
- **Java식 사고**: getter/setter와 mutable 필드를 통해 어디서든 값을 읽고 쓴다.
- **Kotlin식 사고**: 프로퍼티와 `data class`를 통해 상태를 값으로 다루고, 필요 시 불변 복사(copy)로 변형한다.

### 5. 완료 판단 기준
- Player 상태를 “프로퍼티 관계도”로 설명하고, 어떤 값이 어떤 이벤트에 의해 변경되는지 말할 수 있다.
- Inventory 변경을 “값 객체 복사/불변 리스트 갱신” 기준으로 설명할 수 있다.

### ▢ 진행 체크
- [ ] 아직 시작하지 않음
- [ ] 개념 이해 중
- [ ] 설명 가능
- [ ] 실제 전환 시도 완료

### ▢ 멘토 세션 확인 포인트
- Player 상태 다이어그램을 말로 제시할 수 있는가?
- 퀘스트/타이틀/인벤토리 간 의존 관계를 불변 값 객체 관점으로 정리했는가?
- 널 가능 여부를 어떻게 정의하고 있는지 설명할 수 있는가?

### ▢ 코드 리뷰 세션 확인 포인트
- Kotlin 코드가 여전히 필드+setter 호출로 상태를 조작하는지 확인한다.
- 프로퍼티를 `var`로 남발하거나 전역 mutable 리스트를 공유하면 Java 사고 잔존으로 판단한다.
- 값 객체를 통해 상태를 전달하고 있는지, 혹은 여전히 참조 공유를 가정하고 있는지 점검한다.

---

## 3단계. 수확·제작 절차에서 입출력 경계를 분리하기

### 1. 단계 정보
- **단계 번호**: 3
- **단계명**: 수확/제작 I/O 경계 분리
- **핵심 목적**: Farm, AnimalFarm, CraftShop의 수확·제작 흐름을 콘솔 입출력과 도메인 로직으로 분리해, Kotlin 표현식 중심 API로 다시 설명한다.

### 2. 학습 목표
- 도메인 순서를 “입력 수집 → 검증 → 결과” 세 구간으로 나누어 설명한다.
- Kotlin 확장 함수/기본 매개값/컬렉션 표현식으로 절차를 재구성할 수 있는 사고를 갖춘다.
- BearCatchesFishGame과 재배 타이머 같은 부수 효과를 로직과 분리할 타이밍을 인지한다.

### 3. 전환 대상
- Farm/AnimalFarm의 재배, 수확, 보상 지급 루틴
- CraftShop의 제작 절차와 필요 자원 검증 흐름
- BearCatchesFishGame과 재배 타이머 연계 방식

### 4. Java ↔ Kotlin 사고 차이
- **Java식 사고**: Scanner 입력 → 즉시 조건 분기 → 도메인 수정까지 한 메서드에서 처리한다.
- **Kotlin식 사고**: 입력 단계와 도메인 단계를 분리하고, 결과를 값(`sealed class`, `Result`)로 돌려주어 후속 로직이 표현식으로 이어진다.

### 5. 완료 판단 기준
- 수확/제작 과정에서 “콘솔 입력이 빠진 순수 로직”을 설명할 수 있다.
- BearCatchesFishGame 승패 결과를 함수 반환값으로 다루는 사고를 설명할 수 있다.

### ▢ 진행 체크
- [ ] 아직 시작하지 않음
- [ ] 개념 이해 중
- [ ] 설명 가능
- [ ] 실제 전환 시도 완료

### ▢ 멘토 세션 확인 포인트
- 수확 절차를 I/O와 도메인 두 층으로 나눠 설명했는가?
- BearCatchesFishGame의 입력 루프를 외부에서 주입한다면 어떻게 설명할지 말할 수 있는가?
- CraftShop에서 재료 검증 결과를 어떻게 표현식으로 돌려줄지 아이디어를 갖고 있는가?

### ▢ 코드 리뷰 세션 확인 포인트
- Kotlin 코드에 Scanner 의존이 도메인 객체 내부에 남아 있는지 확인한다.
- `when`/표현식 대신 if-else 체인이 그대로라면 Java 사고로 판단한다.
- 결과를 값으로 취급하지 않고 콘솔 메시지로만 표현하면 경계 분리가 미흡한 것이다.

---

## 4단계. 비동기 이벤트를 상태 관찰 모델로 사고하기

### 1. 단계 정보
- **단계 번호**: 4
- **단계명**: 비동기 이벤트 상태 관찰
- **핵심 목적**: LevelUpThread, QuestThread, AchieveTitleThread, CultivateTimer가 Player 상태를 어떻게 관찰·변경하는지 분석하고, Kotlin에서 상태 기반 이벤트 모델로 설명한다.

### 2. 학습 목표
- 각 스레드가 관찰하는 조건과 변경하는 상태를 명확히 구분한다.
- Kotlin `thread`, `Duration`, 불변 상태 스냅샷 등 표현을 활용할 수 있는 사고를 구축한다.
- 종료 조건, 이벤트 트리거, 상태 재계산 타이밍을 말로 정리한다.

### 3. 전환 대상
- LevelUpThread의 경험치 확인과 레벨업 절차
- QuestThread의 랜덤 퀘스트 지급 조건과 Player 큐 업데이트
- AchieveTitleThread, CultivateTimer의 업적/재배 완료 알림 구조

### 4. Java ↔ Kotlin 사고 차이
- **Java식 사고**: `while(true)` + `Thread.sleep`으로 무한 반복하며 상태를 즉시 수정한다.
- **Kotlin식 사고**: 이벤트 조건을 충족할 때만 스레드를 동작시키거나 상태 스트림으로 모델링하고, Duration과 조건 기반 루프로 제어한다.

### 5. 완료 판단 기준
- 각 스레드의 관찰 조건과 종료 조건을 Kotlin 상태 모델로 설명할 수 있다.
- “Player 상태 스냅샷을 읽어 이벤트를 방출한다”는 식으로 말할 수 있다.

### ▢ 진행 체크
- [ ] 아직 시작하지 않음
- [ ] 개념 이해 중
- [ ] 설명 가능
- [ ] 실제 전환 시도 완료

### ▢ 멘토 세션 확인 포인트
- 각 스레드가 어떤 상태를 보고 어떤 상태를 바꾸는지 말할 수 있는가?
- 무한 루프를 조건 기반 루프로 바꾼다면 어떤 기준을 적용하겠는가?
- 여러 스레드가 Player를 수정할 때 동기화 대신 어떤 사고 전환을 적용할지 설명했는가?

### ▢ 코드 리뷰 세션 확인 포인트
- Kotlin 코드에서 여전히 무한 루프+sleep이 남아 있는지 확인한다.
- 상태 변경이 이벤트 기반으로 분리되지 않았다면 Java 사고 잔존이다.
- Duration/표현식 기반 상태 확인 대신 하드코딩된 숫자와 전역 상태 접근만 있다면 미완료로 본다.

---

## 5단계. 경계 자원(상점, 미니게임, 사운드) 조율하기

### 1. 단계 정보
- **단계 번호**: 5
- **단계명**: 경계 자원 조율
- **핵심 목적**: 상점, 미니게임, 사운드 플레이어처럼 외부 자원과 상호작용하는 경계 모듈을 Kotlin 방식의 의존성 주입과 자원 관리로 설명한다.

### 2. 학습 목표
- 상점 구매/판매, 미니게임 입력, 사운드 재생을 하나의 경계 레이어에서 제어하는 사고를 확립한다.
- Kotlin `use`나 람다 기반 핸들러로 자원 생명주기를 통제하는 방식을 말로 정리한다.
- Scanner와 오디오 클립을 단일 지점에서 관리하는 의존성 주입 사고를 체득한다.

### 3. 전환 대상
- Merchant의 구매/판매 흐름과 입력 루프
- BearCatchesFishGame의 Scanner 생성/입력 처리 구조
- SoundPlayerUsingClip의 리소스 획득/해제 패턴

### 4. Java ↔ Kotlin 사고 차이
- **Java식 사고**: 클래스마다 새 Scanner/자원 객체를 생성하고 즉시 사용 후 방치한다.
- **Kotlin식 사고**: 최상위 함수나 람다로 의존성을 주입하고, `use`로 리소스를 안전하게 닫는다.

### 5. 완료 판단 기준
- 경계 자원의 생명주기를 설명하고, Kotlin식 자원 관리 패턴으로 말할 수 있다.
- Scanner/오디오 자원을 하나의 컨트롤 포인트에서 관리하는 방법을 설명할 수 있다.

### ▢ 진행 체크
- [ ] 아직 시작하지 않음
- [ ] 개념 이해 중
- [ ] 설명 가능
- [ ] 실제 전환 시도 완료

### ▢ 멘토 세션 확인 포인트
- 상점/미니게임/사운드별로 어떤 의존성을 주입할지 구체적으로 설명했는가?
- 자원 해제 실패 시 어떤 문제가 생기는지, Kotlin에서 어떻게 방지할지 말할 수 있는가?
- Scanner를 공유/주입하는 전략을 계획했는가?

### ▢ 코드 리뷰 세션 확인 포인트
- Kotlin 코드에서 자원 획득/해제가 `use`나 확장 함수로 명시되었는지 확인한다.
- 여전히 각 클래스가 Scanner나 오디오 리소스를 직접 생성해 사용한다면 Java 사고가 남은 것이다.
- 경계 모듈이 의존성 주입 없이 전역 상태에 의존한다면 미완료로 본다.

---

## 진행 및 기록 방법
- 각 단계의 진행 체크를 학습자가 직접 갱신하고, 멘토 및 코드 리뷰어는 해당 상태를 기준으로 질문/검증을 진행한다.
- 실제 Kotlin 전환 코드는 "설명 가능" 체크 이후, "실제 전환 시도 완료" 체크를 통해 문서에 반영한다.
- 세션이 중단되더라도 이 문서의 체크 상태와 확인 포인트를 통해 바로 다음 학습 흐름을 재개할 수 있다.
